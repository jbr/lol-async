initSidebarItems({"enum":[["Insertion","A `insert_with` operation result."],["Preview","The preview of an interactive insertion. It is used by the `insert_with` method and it is the return value of the closure passed to the method."]],"struct":[["IntoIter","An owned iterator over key-vaue entries of a `Map`."],["Iter","An iterator over key-vaue entries of a `Map`. The `Item` of this iterator is a [`ReadGuard`]. This iterator may be inconsistent, but still it is memory-safe. It is guaranteed to yield items that have been in the `Map` since the iterator creation and the current call to `next`. However, it is not guaranteed to yield all items present in the `Map` at some point if the `Map` is shared between threads."],["IterMut","An owned iterator over references to key-vaue entries of a `Map`. The reference to the value is mutable (but not the one to the key)."],["Map","A lock-free map. Implemented using multi-level hash-tables (in a tree fashion) with ordered buckets."],["RandomState","`RandomState` is the default state for [`HashMap`] types."],["ReadGuard","A read-operation guard. This ensures no entry allocation is mutated or freed while potential reads are performed."],["Removed","A removed entry. It can be reinserted at the same `Map` it was removed. It can also be inserted on another `Map`, but only if either the `Map` is dropped, there are no sensitive reads running on that `Map` or both `Map`s share the same incinerator."],["SharedIncin","The shared incinerator used by [`Map`]. You may want to use this type in order to reduce memory consumption of the minimal space required by the incinerator. However, garbage items may be hold for longer time than they would if no shared incinerator were used."]]});