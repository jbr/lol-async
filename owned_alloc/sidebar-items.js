initSidebarItems({"enum":[["MaybeUninitAlloc","Pointer to memory allocaation that might be either initialized or uninitialized. For the drop checker, the type acts as if it contains a `T` due to usage of `PhantomData<T>`."],["RawVecErr","Errors returned by the `RawVec`."]],"struct":[["AllocErr","Error returned from the allocator."],["Cache","A general purpouse cache suitable for saving discarted memory allocations in a tight loop."],["LayoutErr","Error caused by invalid size or alignment."],["OwnedAlloc","Dynamic allocation of a `T` whose memory is considered fully initialized. The allocation and its content are freed on `drop`. Similar to a `Box`. If the size of the allocation is zero, no allocation is performed and a dangling pointer is used (just like in `std`). For the drop checker, the type acts as if it contains a `T` due to usage of `PhantomData<T>`."],["RawVec","Raw Vector allocation. This allocation, instead of holding a pointer to a single `T`, holds a pointer to as many `T` are required. The allocation is resizable and is freed on `drop`. No initialization or deinitialization of the elements is performed. This type may be useful for `Vec`-like types. If the size of the allocation is zero, no allocation is performed and a dangling pointer is used (just like in `std`). For the drop checker, the type acts as if it contains a `T` due to usage of `PhantomData<T>`."],["UninitAlloc","Dynamic allocation of a `T` whose memory is considered uninitialized. The allocation is freed on `drop`. If the size of the allocation is zero, no allocation is performed and a dangling pointer is used (just like in `std`). For the drop checker, the type acts as if it contains a `T` due to usage of `PhantomData<T>`."]]});